#!/usr/bin/env python

# imports
import sys
import numpy as np
import json

# ros imports
import rospy
from std_msgs.msg import String
from nav_msgs.msg import OccupancyGrid
from geometry_msgs.msg import PoseArray, Pose, Quaternion
#path planning imports
from path_planning import Map, plan_path, toQuaternion


class EEPP_node:
    def __init__(self):
    	self.Algorithm = "A*"
        self.alpha = 1.0
    	self.map = None
        # self.currentPos = (-0.5,-0.5)
        self.currentPos = (0.0, 0.0)

        # subscribers
        self.maas_sub = rospy.Subscriber("/maas/poi_data", String, self.maas_callback)
        self.map_sub = rospy.Subscriber("/map", OccupancyGrid, self.map_callback)

        # publisher
        self.mcts_pub = rospy.Publisher("/mcts/path_data", String, queue_size = 10) # jsonified data
        self.current_pub = rospy.Publisher("/eepp/current_array", PoseArray, queue_size = 10)
############################# Subscriber Callback functions ####################
    '''
    Callback Function for when we receive the POI data from the MAAS team.
    Check that we have map info then plan paths to the POIs.
    '''
    def maas_callback(self, data):
        rospy.loginfo("Received POI data")
        if self.map == None:
        	rospy.loginfo("Map has not yet been recieved! Unable to plan paths to POIs.")
        	return

        message = json.loads(data.data)
        robot_node = dict()
        robot_node["x"] = self.currentPos[0]
        robot_node["y"] = self.currentPos[1]
        robot_node["poi_id"] = message[0]["poi_id"]+1
        robot_node["poi_reward"] = 0.0
        robot_node["connectivity"]= list(message[0]["poi_id"])
        robot_node["has_agent"] = 0
        robot_node["cost"] = 0
        robot_node["path"] = list()
        message.append(robot_node)

        for idx, node in enumerate(message):
            path, cost = plan_path(self.map, self.currentPos, (node["x"], node["y"]), self.Algorithm, self.alpha)
            message[idx]["path"] = path
            message[idx]["cost"] = cost
            message[idx]["connectivity"] = list()
            message[idx]["has_agent"] = -1
            self.currentPos = (node["x"], node["y"])
        self.publish_paths(message)

    '''
    Callback Function for when we receive the map from the map_server node. Take the occupancygrid and derive the info we need.
    '''
    def map_callback(self, msg):
        rospy.loginfo("Received map data!")
        self.map = Map(msg)
        current_message = self.getCurrentmsg()
        self.current_pub.publish(current_message)


    def getCurrentmsg(self):
        map = self.map
        pa = PoseArray()
        pa.header.frame_id = "map"
        for i in range(0,map.width,10):
            for j in range(0,map.height,10):
                x = i*map.res
                y = j*map.res
                p = Pose()
                p.position.x = float(x) + map.pos[0]
                p.position.y = float(y) + map.pos[1]
                p.position.z = 0.0

                cx, cy = map.current.current_x[j,i],map.current.current_y[j,i]
                yaw = np.arctan2(cy,cx)
                p.orientation = toQuaternion(yaw)
                pa.poses.append(p)
        return pa

############################# Publisher functions ##############################
    '''
    Publish POI data with paths and costs to the MCTS team.
    '''
    def publish_paths(self, message):
        self.mcts_pub.publish(json.dumps(message))




############################# Main #############################################
'''
Motly boilerplate for instantiating the node
'''
def main():
    # init ros node
    rospy.init_node('EEPP', anonymous = True)

    # class instance
    EEPP = EEPP_node()

    # create ros loop
    pub_rate = 1 # hertz
    rate = rospy.Rate(pub_rate)
    while (not rospy.is_shutdown()):
        # do some stuff if necessary (we only publish reactively in sub callback)

        # ros sleep (sleep to maintain loop rate)
        rate.sleep()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
